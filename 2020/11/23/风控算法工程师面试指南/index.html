<!DOCTYPE html>


  <html class="light page-post">


<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>风控算法工程师面试指南 | Lixin</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="机器学习、数据挖掘" />
  

  <meta name="description" content="风控模型师面试指南一. 算法1.逻辑回归1.1  逻辑回归的优缺点，在金融领域相比其他算法有什么优势，局限性在哪？ 1）优点：  实现简单，速度快，占用内存小，可在短时间内迭代多个版本的模型。 模型的可解释性非常好，可以直接看到各个特征对模型结果的影响，可解释性在金融领域非常重要，所以在目前业界大部分使用的仍是逻辑回归模型。 模型客群变化的敏感度不如其他高复杂度模型，因此稳健更好，鲁棒性更强。 特">
<meta property="og:type" content="article">
<meta property="og:title" content="风控算法工程师面试指南">
<meta property="og:url" content="https:&#x2F;&#x2F;stringsli.github.io&#x2F;2020&#x2F;11&#x2F;23&#x2F;%E9%A3%8E%E6%8E%A7%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97&#x2F;index.html">
<meta property="og:site_name" content="Lixin">
<meta property="og:description" content="风控模型师面试指南一. 算法1.逻辑回归1.1  逻辑回归的优缺点，在金融领域相比其他算法有什么优势，局限性在哪？ 1）优点：  实现简单，速度快，占用内存小，可在短时间内迭代多个版本的模型。 模型的可解释性非常好，可以直接看到各个特征对模型结果的影响，可解释性在金融领域非常重要，所以在目前业界大部分使用的仍是逻辑回归模型。 模型客群变化的敏感度不如其他高复杂度模型，因此稳健更好，鲁棒性更强。 特">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https:&#x2F;&#x2F;www.zhihu.com&#x2F;equation?tex=%5Cfrac%7BTP%7D%7BTP%2BFN%7D">
<meta property="og:image" content="https:&#x2F;&#x2F;www.zhihu.com&#x2F;equation?tex=%5Cfrac%7BFP%7D%7BFP%2BTN%7D">
<meta property="og:image" content="https:&#x2F;&#x2F;pic3.zhimg.com&#x2F;v2-51c5764548effcfc1348c1390fb47a52_b.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;pic3.zhimg.com&#x2F;80&#x2F;v2-51c5764548effcfc1348c1390fb47a52_hd.jpg">
<meta property="og:updated_time" content="2021-04-01T03:43:58.959Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;www.zhihu.com&#x2F;equation?tex=%5Cfrac%7BTP%7D%7BTP%2BFN%7D">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38189205-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>


  
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#风控模型师面试指南"><span class="toc-text">风控模型师面试指南</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-算法"><span class="toc-text">一. 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-逻辑回归"><span class="toc-text">1.逻辑回归</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-11：L1和L2正则化有什么区别？"><span class="toc-text">1.11：L1和L2正则化有什么区别？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-决策树"><span class="toc-text">2.决策树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-集成学习"><span class="toc-text">3.集成学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-特征工程"><span class="toc-text">二. 特征工程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-模型评估和优化"><span class="toc-text">三.模型评估和优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文献"><span class="toc-text">参考文献</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-风控算法工程师面试指南" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">风控算法工程师面试指南</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2020.11.23</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Lixin</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="风控模型师面试指南"><a href="#风控模型师面试指南" class="headerlink" title="风控模型师面试指南"></a>风控模型师面试指南</h1><h2 id="一-算法"><a href="#一-算法" class="headerlink" title="一. 算法"></a><strong>一. 算法</strong></h2><h2 id="1-逻辑回归"><a href="#1-逻辑回归" class="headerlink" title="1.逻辑回归"></a><strong>1.逻辑回归</strong></h2><p><strong>1.1  逻辑回归的优缺点，在金融领域相比其他算法有什么优势，局限性在哪？</strong></p>
<p>1）优点：</p>
<ul>
<li>实现简单，速度快，占用内存小，可在短时间内迭代多个版本的模型。</li>
<li>模型的可解释性非常好，可以直接看到各个特征对模型结果的影响，可解释性在金融领域非常重要，所以在目前业界大部分使用的仍是逻辑回归模型。</li>
<li>模型客群变化的敏感度不如其他高复杂度模型，因此稳健更好，鲁棒性更强。</li>
<li>特征工程做得好，模型的效果不会太差，并且特征工程可以并行开发，大大加快开发的速度。</li>
<li>模型的结果可以很方便的转化为策略规则，且线上部署简单。</li>
</ul>
<p>2）缺点和局限性:</p>
<ul>
<li>容易欠拟合，相比集成模型，准确度不是很高。</li>
<li>对数据的要求比较高，逻辑回归对缺失值，异常值，共线性都比较敏感，且不能直接处理非线性的特征。所以在数据清洗和特征工程上会花去很大部分的时间。</li>
<li>在金融领域对场景的适应能力有局限性，例如数据不平衡问题，高维特征，大量多类特征，逻辑回归在这方面不如决策树适应能力强。</li>
</ul>
<p><strong>1.2 : 逻辑回归是线性模型吗？逻辑回归和线性回归的区别？</strong></p>
<ul>
<li>逻辑回归是一种广义线性模型，它引入了$Sigmod$函数，是非线性模型，但本质上还是一个线性回归模型，因为除去$Sigmod$函数映射关系，其他的算法原理，步骤都是线性回归的。</li>
<li>逻辑回归和线性回归首先都是广义的线性回归，在本质上没多大区别，区别在于逻辑回归多了个$Sigmod$函数，使样本映射到$[0,1]$之间的数值，从而来处理分类问题。另外逻辑回归是假设变量服从伯努利分布，线性回归假设变量服从高斯分布。逻辑回归输出的是离散型变量，用于分类，线性回归输出的是连续性的，用于预测。逻辑回归是用最大似然法去计算预测函数中的最优参数值，而线性回归是用最小二乘法去对自变量因变量关系进行拟合。</li>
</ul>
<p><strong>1.3：逻辑回归做分类的样本应该满足什么分布？</strong></p>
<p>应该满足伯努利分布，逻辑回归的分类标签是基于样本特征通过伯努利分布产生的，分类器要做的就是估计这个分布。</p>
<p><strong>1.4：逻辑回归解决过拟合的方法有哪些？</strong></p>
<ul>
<li>减少特征数量，在实际使用中会用很多方法进行特征筛选，例如基于$IV$值的大小，变量的稳定性，变量之间的相关性等。</li>
<li>正则化，常用的有$L1$正则化和$L2$正则化。</li>
</ul>
<p><strong>1.5：什么是特征的离散化和特征交叉？逻辑回归为什么要对特征进行离散化？</strong></p>
<ul>
<li>特征离散化是将数值型特征（一般是连续型的）转变为离散特征，例如评分卡中的$woe$转化，就是将特征进行分箱，再将每个分箱映射到$woe$值上，就转换为了离散特征。特征交叉也叫作特征组合，是将单独的特征进行组合，使用相乘/相除/笛卡尔积等形成合成特征，有助于表示非线性关系。比如使用$One-Hot$向量的方式进行特征交叉。这种方式一般适用于离散的情况，我们可以把它看做基于业务理解的逻辑和操作，例如经度和纬度的交叉，年龄和性别的交叉等。</li>
<li>实际工作中很少直接将连续型变量带入逻辑回归模型中，而是将特征进行离散化后再加入模型，例如评分卡的分箱和$woe$转化。这样做的优势有以下几个：1）特征离散化之后，起到了简化模型的作用，使模型变得更稳定，降低了模型过拟合的风险。2）离散化之后的特征对异常数据有很强的鲁棒性，实际工作中的哪些很难解释的异常数据一般不会做删除处理，如果特征不做离散化，这个异常数据带入模型，会给模型带来很大的干扰。3）离散特征的增加和减少都很容易，且稀疏向量的内积乘法运算速度快，易于模型的快速迭代。4）逻辑回归属于广义线性模型，表达能力有限，特征离散化之后，每个离散变量都有单独的权重，相当于给模型引入了非线性，能够提高模型的表达能力。5）离散化后的特征可进行特征交叉，进一步引入非线性，提高模型的表达能力。</li>
</ul>
<p><strong>1.6：在逻辑回归中，为什么要常常做特征组合（特征交叉）？</strong></p>
<p>逻辑回归模型属于线性模型，线性模型不能很好处理非线性特征，特征组合可以引入非线性特征，提升模型的表达能力。另外，基本特征可以认为是全局建模，组合特征更加精细，是个性化建模，但对全局建模会对部分样本有偏，对每一个样本建模又会导致数据爆炸，过拟合，所以基本特征+特征组合兼顾了全局和个性化。</p>
<p><strong>1.7 ：做评分卡中为什么要进行WOE化？</strong></p>
<ul>
<li>更好的解释性，变量离散化之后可将每个箱体映射到woe值，而不是通常做one-hot转换。</li>
<li>woe化之后可以计算每个变量的IV值，可用来筛选变量。</li>
<li>对离散型变量，woe可以观察各个level间的跳转对odds的提升是否呈线性。</li>
<li>对连续型变量，woe和IV值为分箱的合理性提供了一定的依据，也可分析变量在业务上的可解释性。</li>
<li>用woe编码可以处理缺失值问题。</li>
</ul>
<p><strong>1.8：高度相关的特征带入逻辑回归到底有什么影响？为什么逻辑回归要将高度相关特征剔除？</strong></p>
<ul>
<li>在损失函数最终收敛的情况下，就算有很多相关度很高的特征，也不会影响模型的效果。假设一个特征将它重复100次，生成100个高度相关的特征。那么模型训练完之后，这100个特征和原来那一个特征扮演的效果一样，每一个特征的权重都是原来特征的1/100，只是可能中间很多特征的系数正负相互抵消了，比如做评分卡，如果引入了高度相关的特征，那么最后逻辑回归的系数符号可能就会不一致。</li>
<li>虽然高度相关特征对模型结果没什么大的影响，但还是要剔除相关性高的特征，原因是一个可以减少特征数量，提高模型的训练速度，减少过拟合的风险。二是去掉高相关特征可以让模型的可解释性更好。尤其在做评分卡时，为了使最后每个特征的系数符号一致，必须做特征相关性筛选。</li>
</ul>
<p><strong>1.9：逻辑回归的特征系数的绝对值可以认为是特征的重要性吗？</strong></p>
<p>首先特征系数的绝对值越大，对分类效果的影响越显著，但不能表示系数更大的特征重要性更高。因为改变变量的尺度就会改变系数的绝对值，而且如果特征是线性相关的，则系数可以从一个特征转移到另一个特征，特征间相关性越高，用系数解释变量的重要性就越不可靠。</p>
<p><strong>1.10：逻辑回归为什么要用极大似然函数作为损失函数？</strong></p>
<ul>
<li>如果用最小二乘法，目标函数就是 $E_{w,b}=\sum_{i=1}^{m}\left ( y_{i}-\frac{1}{1+e^{-\left ( w^{T}x_{i}+b \right )}}\right )^2$ ,是非凸的，不容易求解，会得到局部最优。</li>
<li>如果用最大似然估计，目标函数就是对数似然函数： $l_{w,b}=\sum_{i=1}^{m}\left ( -y_{i}\left ( w^{T}x_{i}+b \right )+ln\left ( 1+e^{w^{T}x_{i}+b} \right ) \right )$,是关于 $(w,b)$ 的高阶连续可导凸函数，可以方便通过一些凸优化算法求解，比如梯度下降法、牛顿法等。  </li>
</ul>
<h5 id="1-11：L1和L2正则化有什么区别？"><a href="#1-11：L1和L2正则化有什么区别？" class="headerlink" title="1.11：L1和L2正则化有什么区别？"></a>1.11：L1和L2正则化有什么区别？</h5><p>​    L0正则化的值是模型参数中非零参数的个数。</p>
<p>​    L1正则化表示各个参数绝对值之和。</p>
<p>​    L2正则化标识各个参数的平方的和的开方值。</p>
<p>​    先讨论几个问题：</p>
<p>1）实现参数的稀疏有什么好处吗？</p>
<p>​    一个好处是可以简化模型，避免过拟合。因为一个模型中真正重要的参数可能并不多，如果考虑所有的参数起作用，那么可以对 训练数据可以预测的很好，但是对<strong>测试</strong>数据就只能呵呵了。另一个好处是参数变少可以使整个模型获得更好的可解释性。</p>
<p>2）参数值越小代表模型越简单吗？</p>
<p>​    是的。为什么参数越小，说明模型越简单呢，这是因为越复杂的模型，越是会尝试对所有的样本进行拟合，甚至包括一些异常样本点，这就容易造成在较小的区间里预测值产生较大的波动，这种较大的波动也反映了在这个区间里的导数很大，而只有较大的参数值才能产生较大的导数。因此复杂的模型，其参数值会比较大。</p>
<p>根据上面的讨论，稀疏的参数可以防止过拟合，因此用L0范数（非零参数的个数）来做正则化项是可以防止过拟合的。</p>
<p>​    从直观上看，利用非零参数的个数，可以很好的来选择特征，实现特征稀疏的效果，具体操作时选择参数非零的特征即可。但因为L0正则化很难求解，是个NP难问题，因此一般采用L1正则化。L1正则化是L0正则化的最优凸近似，比L0容易求解，并且也可以实现稀疏的效果。</p>
<p>​    L1正则化在实际中往往替代L0正则化，来防止过拟合。在江湖中也人称Lasso。</p>
<p>​    L1正则化之所以可以防止过拟合，是因为L1范数就是各个参数的绝对值相加得到的，我们前面讨论了，参数值大小和模型复杂度是成正比的。因此复杂的模型，其L1范数就大，最终导致损失函数就大，说明这个模型就不够好。</p>
<p>​    L2正则化可以防止过拟合的原因和L1正则化一样，只是形式不太一样。</p>
<p>​    L2范数是各参数的平方和再求平方根，我们让L2范数的正则项  $||w||^{2}$最小，可以使W的每个元素都很小，都接近于0。但与L1范数不一样的是，它不会是每个元素为0，而只是接近于0。越小的参数说明模型越简单，越简单的模型越不容易产生过拟合现象。</p>
<p>L1正则化可以产生稀疏权值矩阵，即产生一个稀疏模型，因此可以用于特征选择</p>
<p>L2正则化可以防止模型过拟合（overfitting）；一定程度上，L1也可以防止过拟合</p>
<h2 id="2-决策树"><a href="#2-决策树" class="headerlink" title="2.决策树"></a><strong>2.决策树</strong></h2><p><strong>2.1：决策树模型的优缺点及适用性？</strong></p>
<p>优点：</p>
<ul>
<li>易于理解，决策树可以生成IF..TEHN逻辑表达的树结构，可解释性很好。</li>
<li>相比逻辑回归对数据的处理较简单，不太需要做例如数据离散化，归一化等操作。</li>
<li>决策树是目前已知的对于处理非线性交互的最好的算法。</li>
<li>模型的效果比较好，例如随机森林，$xgboost$都是基于决策树构建的。</li>
</ul>
<p>缺点：</p>
<ul>
<li>很容易在训练过程中生成过于复杂的树结构，造成过拟合。</li>
<li>不适合处理高维数据，当属性数量过大时，部分决策树就不适用了。</li>
<li>泛化能力能力比较差，对于没有出现过的值几乎没有办法。</li>
</ul>
<p><strong>2.2：简述一下决策树的原理以及树的构建过程。</strong></p>
<p>决策树时基于树的结构进行决策的，学习过程包括特征选择，决策树的生成和剪枝过程。决策树的学习过程通常是递归地选择最优特征，并用最优特征对数据集进行分割。开始时，构建根节点，选择最优特征，该特征有几种值就划分为多少子集，每个子集递归调用此方法，返回结点，返回的结点就是上一层的子节点，直到所有特征都已经用完，或者数据集只有一维特征为止。</p>
<p><strong>2.3：简述一下ID3，C4.5，CART三类决策树的原理和异同点。</strong></p>
<ul>
<li>ID3选择最佳分割点是基于信息增益的，信息增益越大，表明使用这个属性来划分所获得的“纯度提升”越大。C4.5对ID3进行了改进，因为ID3使用的信息增益对数据划分时，可能出现每个结点只包含一个样本，这些子节点的纯度已经达到最大，但是，这样的决策树并不具有泛化能力，无法对新样本进行预测。且ID3不能处理连续型变量和缺失值。而C4.5使用信息增益率来选择属性，克服了信息增益选择属性时偏向选择值多的属性的不足。且可以处理连续型变量和缺失值。</li>
<li>C4.5是基于ID3的改进版，只能用于分类。而CART树既可以做分类，也可以做回归。CART的本质是对特征空间进行二元划分，所以CART生成的是一颗二叉树，且可以对类别型变量和数值型变量进行分裂。对分类型变量进行划分时，分为等于该属性和不等于该属性，在对连续型变量进行划分时，分为大于和小于，在做分类是使用的是GINI系数作为划分标准，在做回归时使用的是均方误差。</li>
</ul>
<p><strong>2.4：分类树和回归树的区别在哪里？</strong></p>
<ul>
<li>分类树以C4.5为例，在对一个特征进行划分时，是穷举这个特征的每一个阈值，找到使得特征&lt;=阈值和特征&gt;阈值分成的两个分支的熵的最大值，按照该标准分支得到两个新的节点，用同样的方法继续分支，直到得到种类唯一的叶子节点，或者达到预设的终止条件为止。</li>
<li>回归树的流程是类似分类树的，区别在于划分时的标准不再是最大熵，而是最小化均差，如果节点的预测值错的越离谱，均方差越大，通过最小化均差能够找到最可靠的分支依据。</li>
</ul>
<p><strong>2.5：决策树对缺失值是如何处理的？</strong></p>
<p>决策树处理缺失要考虑以下三个问题：</p>
<ol>
<li>当开始选择哪个属性来划分数据集时，样本在某几个属性上有缺失怎么处理：</li>
</ol>
<ul>
<li>忽略这些缺失的样本。</li>
<li>填充缺失值，例如给属性A填充一个均值或者用其他方法将缺失值补全。</li>
<li>计算信息增益率时根据缺失率的大小对信息增益率进行打折，例如计算属性A的信息增益率，若属性A的缺失率为0.9，则将信息增益率乘以0.9作为最终的信息增益率。</li>
</ul>
<ol>
<li>一个属性已经被选择，那么在决定分割点时，有些样本在这个属性上有缺失怎么处理？</li>
</ol>
<ul>
<li>忽略这些缺失的样本。</li>
<li>填充缺失值，例如填充一个均值或者用其他方法将缺失值补全。</li>
<li>把缺失的样本，按照无缺失的样本被划分的子集样本个数的相对比率，分配到各个子集上去，至于那些缺失样本分到子集1，哪些样本分配到子集2，这个没有一定准则，可以随机而动。</li>
<li>把缺失的样本分配给所有的子集，也就是每个子集都有缺失的样本。</li>
<li>单独将缺失的样本归为一个分支。</li>
</ul>
<p>3.决策树模型构建好后，测试集上的某些属性是缺失的，这些属性该怎么处理？</p>
<ul>
<li>如果有单独的缺失值分支，依据此分支。</li>
<li>把待分类的样本的属性A分配一个最常出现的值，然后进行分支预测。</li>
<li>待分类的样本在到达属性A结点时就终止分类，然后根据此时A结点所覆盖的叶子节点类别状况为其分配一个发生概率最高的类。</li>
</ul>
<p><strong>2.6：为什么决策树不需要对数据做归一化等预处理？</strong></p>
<p>决策树是一种概率模型，所以不需要做归一化，因为它不关心变量的值，而是关心变量的分布和变量之间的条件概率，所以归一化这种数值缩放，不影响分裂结点位置。</p>
<p><strong>2.7：如何解决决策树的过拟合问题？</strong></p>
<ul>
<li>预剪枝的方法：通过提前停止树的构建而对树剪枝，是目前解决过拟合的主要方法。常用的剪枝条件包括限制树的深度，限制叶节点最小样本数，限制叶节点的最小样本权重，限制叶节点的信息增益值的阈值等。</li>
<li>后剪枝的方法：首先构造完整的决策树，允许树过度拟合数据，然后应单个结点代替子树，节点的分类采用子树的主要分类。剪枝方法有错误率降低剪枝，悲观错误剪枝，代价复杂度剪枝</li>
</ul>
<h2 id="3-集成学习"><a href="#3-集成学习" class="headerlink" title="3.集成学习"></a><strong>3.集成学习</strong></h2><p><strong>3.1：什么是集成学习？集成学习有哪些框架？简单介绍各个框架的常用算法。</strong></p>
<ul>
<li>集成学习是一种优化手段和策略，通常是结合多个简单的弱分类器来集成模型组，去做更可靠的决策。一般的弱分类器可以是决策树，$SVM$，$kNN$等构成，其中的模型可以单独来训练，并且这些弱分类器以某种方式结合在一起去做出一个总体预测。集成学习就是找出哪些弱分类器可以结合在一起，以及如何结合的方法。目前集成学习主要有$bagging$，$boosting$，$stacking$三种：</li>
<li>$bagging$：对训练集进行随机子抽样，对每个子训练集构建基模型，对所有的基模型的预测结果进行综合产生最后的预测结果。如果是分类算法，则用多数投票法确定最终类别，如果是回归算法，则将各个回归结果做算术平均作为最终的预测值。常用的$bagging$算法：随机森林</li>
<li>$boosting$：训练过程为阶梯状，基模型按照次序进行训练（实际上可以做到并行处理），先给定一个初始训练数据，训练出第一个基模型，根据基模型的表现对样本进行调整，在之前基模型预测错误的样本上投入更多的关注，然后用调整后的样本训练下一个基模型，重复上述过程N次，将N个基模型进行加权结合，输出最后的结果。常用的算法有GBDT，XGBOOST等。</li>
<li>$stacking$：是一种组合分类器的方法，以两层为例，第一层由多个基学习器组成，其输入为原始训练集，第二层的模型则是以第一层基学习器的输出作为训练集进行再训练(一般用LR进行回归组合），从而得到完整的$stacking$模型。要得到$stacking$模型，关键在于如何构造第二层的特征，构造第二层特征的原则是尽可能的避免信息泄露，因此对原始训练集常常采用类似于K折交叉验证的划分方法。各个基模型要采用相同的$Kfold$，这样得到的第二层特征的每一折（对应于之前的K折划分）都将不会泄露进该折数据的目标值信息 ，从而尽可能的降低过拟合的风险。</li>
</ul>
<p><strong>3.2: 简单描述一下模型的偏差和方差？bagging和boosting主要关注哪个？</strong></p>
<ul>
<li>偏差描述的是预测值与真实值的差距，偏差越大，越偏离真实数据。</li>
<li>方差描述的是预测值的变化范围，离散程度，方差越大，数据分布越分散。</li>
<li>Bagging算法是对训练样本进行采样，产生出若干不同的子集，再从每个数据子集中训练出一个分类器，取这些分类器的平均，所以是降低模型的方差（variance）。Bagging算法和Random Forest这种并行算法都有这个效果。Boosting则是迭代算法，每一次迭代都根据上一次迭代的预测结果对样本进行权重调整，所以随着迭代不断进行，误差会越来越小，所以模型的偏差（bias）会不断降低。</li>
</ul>
<p><strong>3.3：简述一下随机森林的原理，随机森林的构造过程。</strong></p>
<p>随机森林是$bagging$算法的代表，使用了CART树作为弱分类器，将多个不同的决策树进行组合，利用这种组合来降低单棵决策树的可能带来的片面性和判断不准确性。对于普通的决策树，是在所有样本特征中找一个最优特征来做决策树的左右子树划分，而随机森林会先通过自助采样的方法（bootstrap）得到$N$个训练集，然后在单个训练集上会随机选择一部分特征，来选择一个最优特征来做决策树的左右子树划分，最后得到N棵决策树，对于分类问题，按多数投票的准则确定最终结果，对于回归问题，由多棵决策树的预测值的平均数作为最终结果。随机森林的随机性体现在两方面，一个是选取样本的随机性，一个是选取特征的随机性，这样进一步增强了模型的泛化能力。</p>
<p><strong>3.4：随机森林的优缺点？</strong></p>
<p>优点：</p>
<ul>
<li>训练可以高度并行化，训练速度快，效率高。</li>
<li>两个随机性的引入，使得随机森林不容易过拟合，具有很好的抗噪声能力。</li>
<li>由于每次不再考虑全部的特征属性，二是特征的一个子集，所以相对于bagging计算开销更小，效率更高。</li>
<li>对于数据的适应能力强，可以处理连续型和离散型的变量，数据无需规范化。</li>
<li>可以输出变量的重要程度，被认为是一种不错的降维方法。</li>
</ul>
<p>缺点：</p>
<ul>
<li>在某些噪声较大的分类问题和或回归问题上容易过拟合。</li>
<li>模型的可解释性比较差，无法控制模型内部的运行。</li>
<li>对于小数据或者低维数据，效果可能会不太好。</li>
</ul>
<p><strong>3.5：随机森林为什么不容易过拟合？</strong></p>
<p>随机森林由很多棵树组合在一起，单看每一棵树可以是过拟合的，但是既然是过拟合，就会拟合到非常小的细节，随机森林通过引入随机性，让每一棵树过拟合的细节不同，再将这些树组合在一起，过拟合的部分就会抵消掉，不过随机森林还是可能会出现过拟合的现象，只是出现的概率相对较低。</p>
<p><strong>3.6：随机森林输出特征重要性的原理？</strong></p>
<ul>
<li>随机森林对于特征重要性的评估思想：判断每个特征在随机森林中的每颗树上做了多大的贡献，然后取个平均值，最后比一比特征之间的贡献大小。其中关于贡献的计算方式可以是基尼指数或袋外数据错误率。</li>
<li>基于基尼系数：如果特征X出现在决策树J中的结点M，则计算节点M分枝前后的Gini指数变化量，假设随机森林由N棵树，则计算N次的Gini系数，最后将所有的Gini系数做一个归一化处理就得到了该特征的重要性。</li>
<li>基于袋外数据错误率：袋外数据指的是每次随机抽取未被抽取达到的数据，假设袋外的样本数为O，将这O个数据作为测试集，代入已生成好的随机森林分类器，得到预测的分类结果，其中预测错误的样本数为X，则袋外数据误差为X/O，这个袋外数据误差记为errOOB1，下一步对袋外数据的特征A加入噪声干扰，再次计算袋外误差errOOB2，假设随机森林由N个分类器，则特征A的重要性为：sum(errOOB2-errOOB1)/N,其依据就是，如果一个特征很重要，那么其变动后会非常影响测试误差，如果测试误差没有怎么改变，则说明特征A不重要。</li>
</ul>
<p><strong>3.7：简单描述一下Adaboost的算法原理和流程。</strong></p>
<ul>
<li>Adaboost基于分类器的错误率分配不同的权重系数，最后得到累加加权的的预测结果。</li>
</ul>
<p>算法流程：</p>
<ul>
<li>给数据中每一个样本一个权重，若有N个样本，则每个样本的权重为1/N.</li>
<li>训练数据的每一个样本，得到第一个分类器。</li>
<li>计算该分类器的错误率，根据错误率计算给分类器分配的权重。</li>
<li>将第一个分类器分错的样本权重增加，分对的样本权重减少，然后再用新的样本权重训练数据，得到新的分类器。</li>
<li>迭代这个训练步骤直到分类器错误为0或达到迭代次数。</li>
<li>将所有的弱分类器加权求和，得到分类结果（分类器权重），错误率低的分类器获得更高的决定系数，从而在数据进行预测起关键作用。</li>
</ul>
<p><strong>3.8：Adaboost的优点和缺点？</strong></p>
<p>优点：</p>
<ul>
<li>分类精度高，构造简单，结果可理解。</li>
<li>可以使用各种回归分类模型来构建弱学习器，非常灵活。</li>
<li>不容易过拟合。</li>
</ul>
<p>缺点：</p>
<ul>
<li>训练时会过于偏向分类困难的数据，导致Adaboost容易受噪声数据干扰。</li>
<li>依赖于弱分类器，训练时间可能比较长。</li>
</ul>
<p><strong>3.9：简单说一下GBDT的原理。</strong></p>
<ul>
<li><strong>GBDT是boosting的一种方法，主要思想是每一次建立单个分类器时，是在之前建立的模型的损失函数的梯度下降方向。损失函数越大，说明模型越容易出错，如果我们的模型能让损失函数持续的下降，则说明我们的模型在持续不断的改进，而最好的方式就是让损失函数在其梯度的方向上下降。</strong></li>
<li>GBDT的核心在于每一棵树学的是之前所有树结论和的残差，残差就是真实值与预测值的差值，所以为了得到残差，GBDT中的树全部是回归树，之所以不用分类树，是因为分类的结果相减是没有意义的。</li>
<li>Shrinkage（缩减）是 GBDT 的一个重要演进分支，Shrinkage的思想在于每次走一小步来逼近真实的结果，要比直接迈一大步的方式更好，这样做可以有效减少过拟合的风险。它认为每棵树只学到了一小部分，累加的时候只累加这一小部分，通过多学习几棵树来弥补不足。这累加的一小部分（步长*残差）来逐步逼近目标，所以各个树的残差是渐变的而不是陡变的。</li>
<li>GBDT可以用于回归问题（线性和非线性），也可用于分类问题。</li>
</ul>
<p><strong>3.10：为什么对于高维稀疏特征不太适合用GBDT？</strong></p>
<ul>
<li>GBDT在每一次分割时需要比较大量的特征，特征太多，模型训练很耗费时间。</li>
<li>树的分割往往只考虑了少部分特征，大部分的特征都用不到，所有的高维稀疏的特征会造成大量的特征浪费。</li>
</ul>
<p><strong>3.11：GBDT和随机森林的异同点？</strong></p>
<p>相同点：</p>
<ul>
<li>都是由多棵树构成，最终的结果也是由多棵树决定。</li>
</ul>
<p>不同点：</p>
<ul>
<li>随机森林可以由分类树和回归树组成，GBDT只能由回归树组成。</li>
<li>随机森林的树可以并行生成，而GBDT只能串行生成，所以随机森林的训练速度相对较快。</li>
<li>随机森林关注减小模型的方差，GBDT关注减小模型的偏差。</li>
<li>随机森林对异常值不敏感，GBDT对异常值非常敏感。</li>
<li>随机森林最终的结果是多数投票或简单平均，而GBDT是加权累计起来。</li>
</ul>
<p><strong>3.12：GBDT的优缺点？</strong></p>
<p>优点：</p>
<ul>
<li>GBDT每一次的残差计算都增大了分错样本的权重，而分对的权重都趋近于0，因此泛化性能比较好。</li>
<li>可以灵活的处理各种类型的数据。</li>
</ul>
<p>缺点：</p>
<ul>
<li>对异常值比较敏感。</li>
<li>由于分类器之间存在依赖关系，所以很难进行并行计算。</li>
</ul>
<p><strong>3.13：XGBOOST和GBDT的区别在哪里？</strong></p>
<ul>
<li>传统的GBDT是以CART树作为基分类器，xgboost还支持线性分类器，这个时候xgboost相当于带L1和L2正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题），线性分类器的速度是比较快的，这时候xgboost的速度优势就体现了出来。</li>
<li>传统的GBDT在优化时只使用一阶导数，而xgboost对损失函数做了二阶泰勒展开，同时用到了一阶和二阶导数，并且xgboost支持使用自定义损失函数，只要损失函数可一阶，二阶求导。</li>
<li>xgboost在损失函数里加入了正则项，用来减小模型的方差，防止过拟合，正则项里包含了树的叶节点的个数， 每个叶子节点上输出的score的L2模的平方和。</li>
<li>xgboost里有一个参数叫学习速率（learning_rate）， xgboost在进行完一次迭代后，会将叶子节点的权重乘上学习速率，主要是为了削弱每棵树的影响，让后面有更大的学习空间。实际应用中，一般把learing_rate设置得小一点，然后迭代次数(n_estimators)设置得大一点。</li>
<li>xgboost借鉴了随机森林的原理，支持行抽样(subsample)和列抽样(colsample_bytree,colsample_bylevel)， 行抽样指的是随机森林里对数据集进行有放回抽样，列抽样指的是对特征进行随机选择，不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。</li>
</ul>
<p><strong>3.14：为什么XGBOOST要用泰勒展开，优势在哪里？</strong></p>
<p>xgboost使用了一阶和二阶偏导，二阶导数有利于梯度下降的更快更准，使用泰勒展开取得函数做自变量的二阶导数形式，可以在不选定损失函数具体形式的情况下，仅仅依靠输入数据的值就可以进行叶子分裂优化计算，本质上也就把损失函数的选取和模型算法的优化分开来了，这种去耦合增加了xgboost的适用性，使得它按需选取损失函数，既可以用于分类，也可以用于回归。</p>
<p><strong>3.15：XGBOOST是如何寻找最优特征的？</strong></p>
<p>xgboost在训练过程中给出各个特征的增益评分，最大增益的特征会被选出来作为分裂依据，从而记忆了每个特征在模型训练时的重要性，从根到叶子中间节点涉及某特征的次数作为该特征重要性排序。</p>
<p><strong>3.16：XGBOOST是如何处理缺失值的？</strong></p>
<p>xgboost为缺失值设定了默认的分裂方向，xgboost在树的构建过程中选择能够最小化训练误差的方向作为默认的分裂方向，即在训练时将缺失值划入左子树计算训练误差，再划入右子树计算训练误差，然后将缺失值划入误差小的方向。</p>
<p><strong>3.17：XGBOOST的并行化是如何实现的？</strong></p>
<ul>
<li>xgboost的并行不是在tree粒度上的并行，xgboost也是一次迭代完才能进行下一次迭代（第t次迭代的损失函数包含了第t-1次迭代的预测值），它的并行处理是在特征粒度上的，在决策树的学习中首先要对特征的值进行排序，然后找出最佳的分割点，xgboost在训练之前，就预先对数据做了排序， 然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。</li>
<li>可并行的近似直方图算法。树节点在进行分裂时，我们需要计算每个特征的每个分割点对应的增益，即用贪心法枚举所有可能的分割点。当数据无法一次载入内存或者在分布式情况下，贪心算法效率就会变得很低，所以xgboost还提出了一种可并行的近似直方图算法，用于高效地生成候选的分割点。</li>
</ul>
<p><strong>3.18：XGBOOST采样时有放回的还是无放回的？</strong></p>
<p>xgboost属于boosting方法的一种，所以采样时样本是不放回的，因而每轮计算样本不重复，另外，xgboost支持子采样，每轮计算可以不使用全部的样本，以减少过拟合。另外一点是xgboost还支持列采样，每轮计算按百分比随机抽取一部分特征进行训练，既可以提高速度又能减少过拟合。</p>
<p><strong>3.19：XGBOOST的调参步骤是怎样的？</strong></p>
<p>PS：这里使用Gridsearch cv来穷举检索最佳的参数，如果时间允许，可以通过设置步数先粗调，再细调。</p>
<ul>
<li>保持learning rate和其他booster相关的参数不变，调节和estimators的参数。learing_rate可设为0.1, max_depth设为4-6之间，min_child_weight设为1，subsample和colsample_bytree设为0.8 ，其他的参数都设为默认值即可。</li>
<li>调节max_depth 和 min_child_weight参数，首先，我们先大范围地粗调参数，然后再小范围地微调。</li>
<li>gamma参数调优</li>
<li>subsample和colsample_bytree 调优</li>
<li>正则化参数调优，选择L1正则化或者L2正则化</li>
<li>缩小learning rate，得到最佳的learning rate值</li>
</ul>
<p><strong>3.20：XGBOOST特征重要性的输出原理？</strong></p>
<p>xgboost是用get_score方法输出特征重要性的，其中importance_type<em>参数</em>支持三种特征重要性的计算方法：</p>
<ul>
<li>importance_type<em>=</em>weight（默认值），使用特征在所有树中作为划分属性的次数。</li>
<li>importance_type<em>=</em>gain，使用特征在作为划分属性时loss平均的降低量。</li>
<li>importance_type<em>=</em>cover，使用特征在作为划分属性时对样本的覆盖度。</li>
</ul>
<p><strong>3.21：LightGBM相比XGBOOST在原理和性能上的差异？</strong></p>
<p>1.速度和内存上的优化：</p>
<ul>
<li>xgboost用的是预排序（pre-sorted）的方法， 空间消耗大。这样的算法需要保存数据的特征值，还保存了特征排序的结果（例如排序后的索引，为了后续快速的计算分割点），这里需要消耗训练数据两倍的内存。 其次，时间上也有较大的开销，在遍历每一个分割点的时候，都需要进行分裂增益的计算，消耗的代价大。</li>
<li>LightGBM用的是直方图（Histogram）的决策树算法，直方图算法的基本思想是先把连续的浮点特征值离散化成k个整数，同时构造一个宽度为k的直方图。在遍历数据的时候，根据离散化后的值作为索引在直方图中累积统计量，当遍历一次数据后，直方图累积了需要的统计量，然后根据直方图的离散值，遍历寻找最优的分割点。</li>
</ul>
<p>2.准确率上的优化：</p>
<ul>
<li>xgboost 通过level（depth）-wise策略生长树， Level-wise过一次数据可以同时分裂同一层的叶子，容易进行多线程优化，也好控制模型复杂度，不容易过拟合。但实际上Level-wise是一种低效的算法，因为它不加区分的对待同一层的叶子，带来了很多没必要的开销，因为实际上很多叶子的分裂增益较低，没必要进行搜索和分裂。</li>
<li>LightGBM通过leaf-wise（best-first）策略来生长树， Leaf-wise则是一种更为高效的策略，每次从当前所有叶子中，找到分裂增益最大的一个叶子，然后分裂，如此循环。因此同Level-wise相比，在分裂次数相同的情况下，Leaf-wise可以降低更多的误差，得到更好的精度。Leaf-wise的缺点是可能会长出比较深的决策树，产生过拟合。因此LightGBM在Leaf-wise之上增加了一个最大深度的限制，在保证高效率的同时防止过拟合。</li>
</ul>
<p>3.对类别型特征的处理<strong>：</strong></p>
<ul>
<li>xgboost不支持直接导入类别型变量，需要预先对类别型变量作亚编码等处理。如果类别型特征较多，会导致哑变量处理后衍生后的特征过多，学习树会生长的非常不平衡，并且需要非常深的深度才能来达到较好的准确率。</li>
<li>LightGBM可以支持直接导入类别型变量（导入前需要将字符型转为整数型，并且需要声明类别型特征的字段名），它没有对类别型特征进行独热编码，因此速度比独热编码快得多。LightGBM使用了一个特殊的算法来确定属性特征的分割值。基本思想是对类别按照与目标标签的相关性进行重排序，具体一点是对于保存了类别特征的直方图根据其累计值(sum_gradient/sum_hessian)重排序,在排序好的直方图上选取最佳切分位置。</li>
</ul>
<h2 id="二-特征工程"><a href="#二-特征工程" class="headerlink" title="二. 特征工程"></a><strong>二. 特征工程</strong></h2><p><strong>4.1：什么是特征工程？为什么特征工程对机器学习很重要？</strong></p>
<ul>
<li>特征工程指的是使用专业知识和技巧来处理数据，使得特征在机器学习算法上发挥更好的作用的过程。这个过程包含了数据预处理，特征构建，特征筛选等。特征工程的目的就是筛选出好的特征，得到更好的训练数据，使模型达到更好的效果。</li>
<li>从数据中提取出来的特征好坏会直接影响到模型的效果，有的时候，如果特征工程做得好，仅使用一些简单的机器学习算法，也能达到很好的效果。由此可见特征工程在实际的机器学习中的重要性。</li>
</ul>
<p><strong>4.2：特征工程的一般步骤是什么？什么是特征工程的迭代？</strong></p>
<p>特征工程常规步骤：</p>
<ul>
<li>数据获取，数据的可用性评估（覆盖率，准确率，获取难度）</li>
<li>探索性数据分析，对数据和特征有一个大致的了解，同时进行数据的质量检验，包括缺失值，异常值，重复值，一致性，正确性等。</li>
<li>特征处理，包括数据预处理和特征转换两部分，数据预处理主要做清洗工作（缺失值，异常值，错误值，数据格式），特征转换即对连续特征，离散特征，时间序列特征进行转换，便于入模。</li>
<li>特征构建，特征构建的目的是找寻与目标变量相关且区分度较好的特征。常用的方法有特征交叉，四则运算，基于业务理解进行头脑风暴构建特征等。</li>
<li>特征筛选，大量的特征中选择少量的有用特征，也叫作特征降维，常用的方法有过滤法，包装法，嵌入法。</li>
</ul>
<p>特征工程的迭代:</p>
<ul>
<li>选择特征：具体问题具体分析，通过查看大量的数据和基于对业务的理解，从数据中查找可以提出出数据的关键。</li>
<li>设计特征：可以自动进行特征提取工作，也可以手工进行特征的构建。</li>
<li>选择特征：使用不同的特征构造方法，从多个角度来评判这个特征是否适合放入模型中。</li>
<li>计算模型：计算模型在该特征上所提升的准确率。</li>
<li>上线测试：通过在线测试的效果来评估特征是否有效。</li>
</ul>
<p><strong>4.3：常用的特征工程方法有哪些？</strong></p>
<ul>
<li>特征处理：数据的预处理包括异常值和缺失值，要根据实际的情况来处理。特征转换主要有标准化，归一化，区间缩放，二值化等，根据特征类型的不同选择合适的转换方法。</li>
<li>特征构建：特征之间的四则运算（有业务含义）,基于业务理解构造特征，分解类别特征，特征交叉组合等。</li>
<li>特征筛选：过滤法，封装法，嵌入法。</li>
</ul>
<p><strong>4.4：在实际的风控建模中怎么做好特征工程？</strong></p>
<p>本人工作中的一些经验总结：</p>
<ul>
<li>因为做风控模型大部分的数据源来自第三方，所以第三方数据的可用性评估非常重要，一方面需要了解这些特征底层的衍生逻辑，判断是否与目标变量相关。另一方面考察数据的覆盖率和真实性，覆盖率较低和真实性存疑的特征都不能使用在模型中。</li>
<li>基于金融的数据特点，在特征筛选这个步骤上考量的因素主要有：一个是时间序列上的稳定性，衡量的指标可以是PSI，方差或者IV。一个是特征在样本上覆盖率，也就是特征的缺失率不能太高。另外就是特征的可解释性，特征与目标变量的关系要在业务上要解释的通。</li>
<li>如果第三方返回有用户的原始底层数据，例如社保的缴纳记录，运营商的通话/短信记录，则需要在特征衍生上多下功夫，基于自身对数据的敏感性和业务的理解，构建具有金融，风险属性的特征，也可以与业务部门进行沟通找寻与业务相关的特征。</li>
</ul>
<p><strong>4.5：实际项目中原始数据通常有哪些问题？你是如何解决的？</strong></p>
<ul>
<li>一些特征的底层逻辑不清晰，字面上的意思可能与实际的衍生逻辑相悖，这个需要与第三方数据供应商进行沟通，了解清楚特征的衍生逻辑。</li>
<li>数据的真实性可能存在问题。比如一个特征是历史总计，但第三方只是爬取了用户近2年的数据，这样的特征就不符合用户的真实情况。所以对数据的真实性校验显得非常重要。</li>
<li>有缺失的特征占的比例较高。在进行缺失值处理前先分析缺失的原因，而不是盲目的进行填充，删除等工作。另外也要分析缺失是否有风险属性，例如芝麻分缺失的用户相对来说风险会较高，那么缺失可以当做一个类别来处理。</li>
<li>大量多类特征如何使用。例如位置信息，设备信息这些特征类别数较多，如果做亚编码处理会造成维度灾难，目前常用的方法一个是降基处理，减少类别数，另一个是用xgboost来对类别数做重要性排序，筛选重要性较高的类别再做亚编码处理。</li>
</ul>
<p><strong>4.6：在做评分卡或其他模型中，怎么衡量特征(数据)的有用性？</strong></p>
<ul>
<li>特征具有金融风险属性，且与目标变量的关系在业务上有良好的可解释性。</li>
<li>特征与目标变量是高度相关的，衡量的指标主要是IV。</li>
<li>特征的准确率，这个需要了解特征的衍生逻辑，并与实际一般的情况相比较是否有异常。</li>
<li>特征的覆盖率，一般来说覆盖率要达到70%以上。</li>
<li>特征的稳定性，特征的覆盖率，分布，区分效果在时间序列上的表现比较稳定。</li>
<li>特征的及时性，最好是能代表用户最近的信用风险情况。</li>
</ul>
<p><strong>4.7：为什么探索性数据分析（EDA）在机器学习中非常重要？</strong></p>
<ul>
<li>EDA不单是看看数据的分布，而是对数据整体有一个大概的了解。通过作图、制表、方程拟合、计算特征量等手段探索数据的结构和规律。从中发现关键性的价值信息，这些信息对于后续建模及对模型的正确理解有很重要的意义。</li>
<li>通过EDA可以发现数据的异常，可以分析每个特征与目标变量之间的关系，特征与特征之间的关系，为特征构建和特征筛选提供有价值的信息。</li>
<li>EDA分析可以验证数据是不是你认为的那样，实际情况中由于数据和特征量比较大，往往忽视这些数据是如何生成的，数据突出的问题或模型的实施中的错误会被长时间忽视，这可能会导致基于错误信息做出决策。</li>
</ul>
<p><strong>4.8：缺失值的处理方式有哪些？风控建模中该如何合理的处理缺失？</strong></p>
<ul>
<li>首先要了解缺失产生的原因，因数据获取导致的缺失建议用填充的方式(缺失率比较低的情况下），因用户本身没有这个属性导致的缺失建议把缺失当做一个类别。另外可以分析缺失是否有风险属性，有的话最好当做一个类别来处理。</li>
<li>风控模型对于缺失率的要求比较高，尤其是评分卡。个人认为，缺失率在30%以上的特征建议不要用，缺失率在10%以下的变量可用中位数或随机森林来填充，10%-30%的缺失率建议当做一个类别。对于xgboost和lightgbm这类可以自动处理缺失值的模型可以不做处理。</li>
</ul>
<p><strong>4.9：如何发现数据中的异常值？对异常值是怎么处理的？</strong></p>
<ul>
<li>一种是基于统计的异常点检测算法例如极差，四分位数间距，均差，标准差等，这种方法适合于挖掘单变量的数值型数据。另一种主要通过距离方法来检测异常点，将数据集中与大多数点之间距离大于某个阈值的点视为异常点，检测的标准有欧式距离，绝对距离。</li>
<li>对于异常值先检查下是不是数据错误导致的，数据错误的异常作删除即可。如果无法判别异常的原因，要根据实际情况而定，像评分卡会做WOE转换，所以异常值的影响不大，可以不做处理。若异常值的数量较多，建议将异常值归为一类，数量较少作删除也可以。</li>
</ul>
<p><strong>4.10：对于时间序列特征，连续特征，离散特征这三类是怎么做特征转换的？</strong></p>
<ul>
<li>时间序列特征：将时间变量的维度进行分离（年/月/日/时/分/秒），或者与位置变量进行结合衍生成新的特征。</li>
<li>连续型特征：标准化，归一化，区间缩放，离散化。在评分卡中主要用的是离散化，离散化常用的方法有卡房分箱，决策树分箱，等频和等深分箱。</li>
<li>离散型特征：如果类别数不是很多，适合做亚编码处理，对于无序离散变量用独热编码，有序离散变量用顺序编码。如果类别数较多，可用平均数编码的方法。</li>
</ul>
<p><strong>4.11：如何处理样本不平衡的问题？</strong></p>
<ul>
<li>在风控建模中出现样本不平衡主要是坏样本的数量太少，碰到这个问题不要急着试各种抽样方法，先看一下坏用户的定义是否过于严格，过于严格会导致坏样本数量偏少，中间样本偏多。坏用户的定义一般基于滚动率分析的结果，不过实际业务场景复杂多样，还是得根据情况而定。</li>
<li>确定好坏用户定义是比较合理的之后，先尝试能不能扩大数据集，比如一开始取得是三个月的用户数据，试着将时间线延长来增加数据。因为机器学习是使用现在的数据在整个数据分布上进行估计，因此更多的数据往往能够得到更多的分布信息，以及更好的分布估计。</li>
<li>对数据集进行抽样，一种是进行欠采样，通过减少大类的数据样本来降低数据的不平衡，另一种是进行过采样，通过增加小类数据的样本来降低不平衡，实际工作中常用SMOTE方法来实现过采样。</li>
<li>尝试使用xgboost和lightgbm等对不平衡数据处理效果较好的模型。</li>
<li>尝试从新的角度来理解问题，可以把那些小类样本当做异常点，因此该分类问题转化为异常检测问题或变化趋势检测问题，这种方法笔者很少用到，就不详细说明了。</li>
</ul>
<p><strong>4.12：特征衍生的方法有哪些？说说你平时工作中是怎么做特征衍生的？</strong></p>
<p>常规的特征衍生方法：</p>
<ul>
<li>基于对业务的深入理解，进行头脑风暴，构造特征。</li>
<li>特征交叉，例如对类别特征进行交叉相乘。</li>
<li>分解类别特征，例如对于有缺失的特征可以分解成是否有这个类别的二值化特征，或者将缺失作为一个类别，再进行亚编码等处理。</li>
<li>重构数值量（单位转换，整数小数拆分，构造阶段性特征）</li>
<li>特征的四则运算，例如取平均/最大/最小，或者特征之间的相乘相除。</li>
</ul>
<p>平时工作特征衍生的做法：</p>
<ul>
<li>因为风控模型通常需要好的解释能力，所以在特征衍生时也会考虑到衍生出来的特征是否与目标变量相关。例如拿到运营商的通话记录数据，可以衍生一个”在敏感时间段（深夜）的通话次数占比”，如果占比较高，用户的风险也较大。</li>
<li>平常会将大量的时间和精力花在底层数据的衍生上，这个不仅需要对业务的理解，也需要一定的想象力进行头脑风暴，即使衍生出来的特征90%都效果不佳，但只要剩下的10%是好的特征，那对于模型效果的提升是很显著的。</li>
<li>对于评分卡来说，特征需要好的解释能力，所以一些复杂的衍生方法，像特征交叉，log转换基本不会用到。但如果是xgboost等复杂模型，进行特征交叉等方法或许有比较好的效果。</li>
</ul>
<p><strong>4.13：特征筛选的作用和目的？筛选的特征需要满足什么要求？</strong></p>
<p>作用和目的：</p>
<ul>
<li>简化模型，增加模型的可解释性， 降低模型过拟合的风险。</li>
<li>缩短模型的训练时间。</li>
<li>避免维度灾难。</li>
</ul>
<p>筛选特征满足的要求：</p>
<ul>
<li>具有良好的区分能力。</li>
<li>可解释性好，与目标变量的关系在业务上能解释的通。</li>
<li>在时间序列上有比较好的稳定性。</li>
<li>特征的用户覆盖率符合要求。</li>
</ul>
<p><strong>4.14：特征筛选的方法有哪些？每种方法的优缺点？实际工作中用到了哪些方法？</strong></p>
<p>Filter（过滤法）：按照发散性或者相关性对各个特征进行评分，设定阈值或者待选择阈值的个数，选择特征。</p>
<ul>
<li>相关系数，方差（适用于连续型变量），卡方检验（适用于类别型变量），信息熵，IV。实际工作中主要基于IV和相关性系数（皮尔逊系数）。</li>
<li>优点：算法的通用性强；省去了分类器的训练步骤，算法复杂性低，因而适用于大规模数据集；可以快速去除大量不相关的特征，作为特征的预筛选器非常合适。</li>
<li>缺点：由于算法的评价标准独立于特定的学习算法，所选的特征子集在分类准确率方面通常低于Wrapper方法。</li>
</ul>
<p>Wrapper（封装法）：封装式特征选择是利用学习算法的性能评价特征子集的优劣。因此，对于一个待评价的特征子集，Wrapper方法需要训练一个分类器，根据分类器的性能对该特征子集进行评价。</p>
<ul>
<li>方法有完全搜索（递归消除法），启发式搜索（前向/后向选择法，逐步选择法），随机搜索（训练不同的特征子集）。实际工作中主要用到启发式搜索，例如评分卡的逐步逻辑回归。</li>
<li>优点：相对于Filter方法，Wrapper方法找到的特征子集分类性能通常更好。</li>
<li>缺点：Wrapper方法选出的特征通用性不强，当改变学习算法时，需要针对该学习算法重新进行特征选择；由于每次对子集的评价都要进行分类器的训练和测试，所以算法计算复杂度很高，尤其对于大规模数据集来说，算法的执行时间很长。</li>
</ul>
<p>Embedded（嵌入法）：先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据系数从大到小选择特征。类似于Filter方法，但是是通过训练来确定特征的优劣。</p>
<ul>
<li>一种是基于惩罚项，例如岭回归，lasso回归，L1/L2正则化。另一种是基于树模型输出的特征重要性，在实际工作中较为常用，可选择的模型有随机森林，xgboost，lightgbm。</li>
<li>优点：效果最好速度最快，模式单调，快速并且效果明显。</li>
<li>缺点：如何参数设置， 需要对模型的算法原理有较好的理解。</li>
</ul>
<h2 id="三-模型评估和优化"><a href="#三-模型评估和优化" class="headerlink" title="三.模型评估和优化"></a><strong>三.模型评估和优化</strong></h2><p><strong>5.1：简单介绍一下风控模型常用的评估指标。</strong></p>
<ul>
<li>混淆矩阵指标：精准率，查全率，假正率。当模型最后转化为规则时，一般用这三个指标来衡量规则的有效性。要么注重精准率，要么注重查全率，两者不可兼而得之。</li>
<li>ROC曲线和AUC值，ROC曲线是一种对于查全率和假正率的权衡，具体方法是在不同阈值下以查全率作为纵轴，假正率作为横轴绘制出一条曲线。曲线越靠近左上角，意味着越多的正例优先于负例，模型的整体表现也就越好。AUC是ROC曲线下面的面积，AUC可以解读为从所有正例中随机选取一个样本A，再从所有负例中随机选取一个样本B，分类器将A判为正例的概率比将B判为正例的概率大的可能性。在对角线（随机线）左边的点上TPR总大于FPR，意为正例被判为正例的概率大于负例被判为正例的概率。从另一个角度看，由于画ROC曲线时都是先将所有样本按分类器的预测概率排序，所以AUC反映的是分类器对样本的排序能力。AUC越大，自然排序能力越好，即分类器将越多的正例排在负例之前。</li>
<li>KS：用于区分预测正负样本分隔程度的评价指标，KS越大，表示模型能将好坏样本区分开的程度越大。KS的绘制方法是先将每个样本的预测结果化为概率或者分数，将最低分到最高分（分数越低，坏的概率越大）进行排序做样本划分，横轴就是样本的累计占比，纵轴则是好坏用户的累计占比分布曲线，KS值为两个分布的最大差值（绝对值）。KS值仅能代表模型的区隔能力，KS不是越高越好，KS如果过高，说明好坏样本分的过于开了，这样整体分数（概率）就是比较极端化的分布状态，这样的结果基本不能用。</li>
<li>基尼系数：其横轴是根据分数（概率）由高到低累计的好用户占总的好用户的比例，纵轴是分数（概率）从高到低坏用户占总的坏用户的比例。由于分数高者为低风险用户，所以累计坏用户比例的增长速度会低于累计好用户比例，因此，基尼曲线会呈现向下弯曲的形式，向下突出的半月形的面积除以下方三角形的面积即是基尼系数。基尼系数越大，表示模型对于好坏用户的区分能力越好。</li>
</ul>
<p><strong>5.2：为什么ROC适合不平衡数据的评价？</strong></p>
<ul>
<li>ROC曲线的纵轴是TPR= <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7BTP%7D%7BTP%2BFN%7D" alt="\frac{TP}{TP+FN}"> ，横轴是FPR= <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7BFP%7D%7BFP%2BTN%7D" alt="\frac{FP}{FP+TN}"> ，TPR聚焦于正例，FPR聚焦于与负例，所以ROC兼顾了正样本和负样本的权衡，使其成为一个比较均衡的评估方法。</li>
<li>因为TPR用到的TP和FN都是正样本，FPR用到的FP和TN都是负样本，所以说正样本或负样本发生了改变，TPR和FPR也不会相互影响，因此即使类别分布发生了改变，数据变得不平衡了，ROC曲线也不会产生大的变化。ROC曲线的优点，即具有鲁棒性，在类别分布发生明显改变的情况下依然能客观地识别出较好的分类器。</li>
</ul>
<p><strong>5.3：AUC和KS的关系是什么？</strong></p>
<p><img src="https://pic3.zhimg.com/v2-51c5764548effcfc1348c1390fb47a52_b.jpg" alt="img"> <img src="https://pic3.zhimg.com/80/v2-51c5764548effcfc1348c1390fb47a52_hd.jpg" alt="img"></p>
<ul>
<li>左图是KS曲线，红色的是TPR曲线（累计正样本占比），蓝色的是FPR曲线（累计负样本占比）。由于按照正样本预测概率降序排列，所以排在前面的样本为正的概率更大，但为正的概率是递减的；相反排在前面的样本为负的概率更小，但为负的概率递增。所以KS图中，TPR曲线在FPR曲线上方，并且TPR曲线的导数递减，FPR曲线的导数递增，而KS曲线先上升到达峰值P点（导数为0）后下降，P点对应的C值就是KS值。ROC图中，ROC曲线的导数是递减的，且刚开始导数大于1，逐渐递减到导数为1的T点（T点对应P点），然后导数继续降低。另外，A值对应X值，B值对应Y值，且C=B-A=Y-X</li>
<li>在用KS评估模型时，除了看P点对应的KS值C，还要看P点的横坐标F值的大小，F值表示的是将分数从低到高排序后的累计样本占比，F值越小，说明模型对正样本的预测越精确，也就是说在识别出正样本的同时也能保证对负样本更小的误杀率。</li>
<li>假设F值不变，C值增大，即P点沿着垂直方向向上移动，那么A值应该减小，B值应该增大；对应地，X值减小，Y值增大，T点会向左上角移动；所以ROC曲线下方的面积会增大，也就是AUC值增大。</li>
<li>假设C值不变，F值减小，即P点沿着水平方向向左移动，因为C=B-A，所以A和B减小相同的幅度，也是就说X和Y减小相同的幅度，即T点沿着斜率为1的切线方向向下移动，此时ROC曲线下方的面积也会增大，即AUC值增大。</li>
<li>所以P点的位置决定了T点的位置，C值和F值均会影响AUC值。AUC值看上去更像一个综合评估指标，但缺乏对模型细节的评估。而KS值结合F值，可以评估每一段评分的效果，还可以找出评分切分的阈值等。</li>
</ul>
<p><strong>5.4：什么是模型的欠拟合和过拟合？</strong></p>
<ul>
<li>欠拟合指的是模型没有很好的捕捉到数据特征，不能很好的拟合数据。</li>
<li>过拟合指的是模型把数据学习的太彻底，以至于把噪声数据学习进去了，这样模型在预测未知数据时，就不能正确的分类，模型的泛化能力太差。</li>
</ul>
<p><strong>5.5：如何判断模型是否存在过拟合或欠拟合？对应的解决方法有哪些？</strong></p>
<ul>
<li>判断模型是否存在过拟合/欠拟合主要用学习曲线，学习曲线指的是通过画出不同训练集大小时训练集和交叉验证的准确率，可以看到模型在新数据上的表现，进而来判断模型是否方差偏高（过拟合）或偏差过高（欠拟合）。当训练集和测试集的误差收敛但却很高时，即为欠拟合，当训练集和测试集的误差之间有大的差距时，为过拟合。</li>
<li>解决欠拟合的方法：增加效果好的特征，添加多项式特征，减小正则化参数等。</li>
<li>解决过拟合的方法：使用更多的数据，选择更加合适的模型，加入正则项等。</li>
</ul>
<p><strong>5.6：什么是正则化？什么是L1正则化和L2正则化？</strong></p>
<ul>
<li>正则化是在模型的loss function的基础上，加上了一些正则化项或者称为模型复杂度惩罚项，它会向学习算法略微做些修正，从而让模型能更好地泛化。这样反过来能提高模型在不可见数据上的性能。</li>
<li>L1正则化就是在loss function后边所加正则项为L1范数，加上L1范数容易得到稀疏解，所以L1正则化会趋向于产生少量的特征。</li>
<li>L2正则化就是loss function后边所加正则项为L2范数的平方，加上L2正则相比于L1正则来说，得到的解比较平滑（不是稀疏），所以L2正则化会使特征的解趋近于0，但不会为0。</li>
</ul>
<p><strong>5.7：正则化为什么可以防止过拟合？</strong></p>
<p>最简单的解释是正则化对模型参数添加了先验，在数据少的时候，先验知识可以防止过拟合。</p>
<p><strong>5.8：什么是交叉验证？交叉验证的目的是什么？有哪些优点？</strong></p>
<p>交叉验证概念：</p>
<p>交叉验证，就是重复的使用数据，把得到的样本数据进行切分，组合为不同的训练集和测试集，用训练集来训练模型，用测试集来评估模型预测的好坏。在此基础上可以得到多组不同的训练集和测试集，某次训练集中的某样本在下次可能成为测试集中的样本，即所谓”交叉”。　</p>
<p>交叉验证的目的：</p>
<p>评估给定算法在特定数据集上训练后的泛化性能，比单次划分训练集和测试集的方法更加稳定，全面。</p>
<p>交叉验证的优点：</p>
<ul>
<li>如果只是对数据随机划分为训练集和测试集，假如很幸运地将难以分类的样本划分进训练集中，则在测试集会得出一个很高的分数，但如果不够幸运地将难以分类的样本划分进测试集中，则会得到一个很低的分数。所以得出的结果随机性太大，不够具有代表性。而交叉验证中每个样本都会出现在训练集和测试集中各一次，因此，模型需要对所有样本的泛化能力都很好，才能使其最后交叉验证得分，及其平均值都很高，这样的结果更加稳定，全面，具有说服力。</li>
<li>对数据集多次划分后，还可以通过每个样本的得分比较，来反映模型对于训练集选择的敏感性信息。</li>
<li>对数据的使用更加高效，可以得到更为精确的模型。</li>
</ul>
<p><strong>5.8：交叉验证常用的方法有哪些？</strong></p>
<ul>
<li>标准K折交叉验证：K是自定义的数字，通常取5或10，如果设为5折，则会训练5个模型，得到5个精度值。</li>
<li>分层K折交叉验证：如果一个数据集经过标准K折划分后，在测试集上只有一种类别，则无法给出分类器整体性能的信息，这种情况用标准K折是不合理的。而在分层K折交叉验证中，每个折中的类别比例与整个数据集类别比例相同，这样能对泛化性能做出更可靠的估计。</li>
<li>留一法交叉验证：每次划分时，把单个数据点作为测试集，如果数据量小，能得到更好的估计结果，数据量很大时则不适用。</li>
<li>打乱划分交叉验证：每次划分数据时为训练集取样train_size个点，为测试集取样test_size个点，将这一划分划分方法重复n_splits次。这种方法还允许每次迭代中使用部分数据，可通过设置train_size和test_size之和不为0来实现，用这种方法对数据进行二次采样可能对大型数据上的试验很用用。另外也有分层划分的形式（ StratifiedShuffleSplit），为分类任务提供更可靠的结果。</li>
<li>分组交叉验证：适用于数据中的分组高度相关时，以group数组作为参数，group数组表示数据中的分组，在创建训练集和测试集的时候不应该将其分开，也不应该与类别标签弄混。</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/56175215" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/56175215</a> </li>
</ol>

    
  </div>

</article>


   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2020/06/29/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2020/11/25/MySQL%E5%92%8COracle%20%E8%A1%A8%E6%B3%A8%E9%87%8A%E5%92%8C%E5%AD%97%E6%AE%B5%E6%B3%A8%E9%87%8A%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
